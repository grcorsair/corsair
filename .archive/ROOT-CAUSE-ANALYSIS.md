# Root Cause Analysis - Corsair MVP API Mismatch

**Date:** 2026-01-31
**Issue:** Demo crashed due to API surface mismatch between implementation and consumer expectations
**Status:** ‚úÖ Core issue FIXED (RECON + MARK working), ‚ö†Ô∏è PLUNDER remains mismatched

---

## Root Cause

**The fundamental problem:** Two competing specifications created during TDD process:

1. **Test Contracts** (what tests validated): Raw primitives for testability
   - `mark()` returns `DriftFinding[]` array
   - Tests assert directly on array elements

2. **Consumer Expectations** (what demo assumed): Rich metadata wrappers for usability
   - Demo expects `markResult.findings`, `markResult.driftDetected`, `markResult.durationMs`
   - Demo expects `reconResult.stateModified`, `reconResult.durationMs` at top level

**Why this happened:**

1. Engineer agent was told: "Make tests pass"
   - Agent implemented to satisfy test assertions (return array, not wrapper)
   - TDD success metric = green tests, not ergonomic API

2. Demo was written independently
   - Assumed rich result objects (reasonable expectation for production API)
   - Never validated against actual implementation

3. No integration layer between unit tests and E2E demo
   - Unit tests validate primitives in isolation
   - Demo validates composition and ergonomics
   - Gap between these two went undetected until demo execution

**The deeper issue:** TDD focused on "functional correctness" (does it compute correctly?) but not "interface ergonomics" (is it pleasant to use?). Both are requirements.

---

## Fixes Applied

### 1. Added MarkResult Wrapper Type ‚úÖ

**Before:**
```typescript
async mark(snapshot: CognitoSnapshot, expectations: Expectation[]): Promise<DriftFinding[]> {
  const findings: DriftFinding[] = [];
  // ... logic ...
  return findings;  // Raw array
}
```

**After:**
```typescript
export interface MarkResult {
  findings: DriftFinding[];
  driftDetected: boolean;
  durationMs: number;
}

async mark(snapshot: CognitoSnapshot, expectations: Expectation[]): Promise<MarkResult> {
  const startTime = Date.now();
  const findings: DriftFinding[] = [];
  // ... logic ...
  const durationMs = Date.now() - startTime;
  const driftDetected = findings.some(f => f.drift === true);

  return {
    findings,
    driftDetected,
    durationMs,
  };
}
```

**Impact:**
- ‚úÖ Demo now works: `markResult.findings.length`
- ‚úÖ Tests updated to access `.findings` property
- ‚úÖ Duration tracking automatic
- ‚úÖ Drift detection computed automatically (no manual check needed)

---

### 2. Enhanced ReconResult with Top-Level Fields ‚úÖ

**Before:**
```typescript
export interface ReconResult {
  snapshot: CognitoSnapshot;
  metadata: ReconMetadata;  // durationMs buried here
}
```

**After:**
```typescript
export interface ReconResult {
  snapshot: CognitoSnapshot;
  metadata: ReconMetadata;
  stateModified: boolean;  // Top-level for easy access
  durationMs: number;      // Top-level (not buried in metadata)
}
```

**Implementation:**
```typescript
return {
  snapshot,
  metadata: {
    source: "fixture",
    readonly: true,
    durationMs,  // Also in metadata for backward compat
  },
  stateModified: false,  // RECON is read-only by contract
  durationMs,  // Top level for ergonomics
};
```

**Impact:**
- ‚úÖ Demo accesses `reconResult.durationMs` directly
- ‚úÖ Demo verifies `reconResult.stateModified === false`
- ‚úÖ No breaking changes (durationMs still in metadata too)

---

### 3. Added Optional Fields to CognitoSnapshot ‚úÖ

**Before:**
```typescript
export interface CognitoSnapshot {
  userPoolId: string;
  userPoolName: string;
  mfaConfiguration: MfaConfiguration;
  // ... other fields ...
  observedAt: string;
}
```

**After:**
```typescript
export interface CognitoSnapshot {
  // ... existing fields ...
  observedAt: string;
  userCount?: number;  // Optional - requires user list parsing
  status?: string;     // Optional - from UserPool.Status
}
```

**Impact:**
- ‚úÖ Demo shows `undefined` instead of crashing
- ‚úÖ Type system allows fields without breaking existing code
- ‚ö†Ô∏è Not populated yet (requires parsing user list from fixtures)

---

### 4. Fixed Demo Expectation Format ‚úÖ

**Before (WRONG):**
```typescript
const expectations: Expectation[] = [
  {
    field: "mfaConfiguration",
    expectedValue: "ON",  // Wrong property name
    severity: "CRITICAL", // Not part of Expectation interface
    rationale: "..."     // Not part of Expectation interface
  }
];
```

**After (CORRECT):**
```typescript
const expectations: Expectation[] = [
  {
    field: "mfaConfiguration",
    operator: "eq",  // Required
    value: "ON"      // Correct property name
  }
];
```

**Impact:**
- ‚úÖ Demo matches actual `Expectation` interface
- ‚úÖ Severity assigned by implementation (not caller)
- ‚úÖ Description generated by implementation

---

### 5. Fixed RAID API Call ‚úÖ

**Before (WRONG):**
```typescript
const raidResult = await corsair.raid({
  target: reconResult.snapshot.userPoolId,
  attackVector: "mfa-bypass",
  blastRadius: "low",
  chaosIntensity: 1
});
```

**After (CORRECT):**
```typescript
const raidResult = await corsair.raid(reconResult.snapshot, {
  vector: "mfa-bypass",
  intensity: 0.8,
  dryRun: false
});
```

**Impact:**
- ‚úÖ Matches actual `raid(snapshot, options)` signature
- ‚úÖ Uses correct `RaidOptions` properties

---

### 6. Updated All Tests to Use New API ‚úÖ

**Changes:**
- `const findings = await corsair.mark(...)` ‚Üí `const result = await corsair.mark(...)`
- `findings.length` ‚Üí `result.findings.length`
- `findings.find(...)` ‚Üí `result.findings.find(...)`
- `corsair.chart(findings)` ‚Üí `corsair.chart(result.findings)`

**Test Results:**
```bash
$ bun test tests/primitives/

bun test v1.3.7 (ba426210)

 50 pass
 0 fail
 202 expect() calls
Ran 50 tests across 6 files. [243.00ms]
```

‚úÖ **All 50 tests pass after changes**

---

## What Works Now ‚úÖ

### RECON Primitive
```
üìä Reconnaissance Complete:
  Pool ID:       us-west-2_OPTIONAL001
  Pool Name:     staging-optional-mfa-pool
  MFA Config:    OPTIONAL
  User Count:    undefined (optional field)
  Status:        undefined (optional field)
  Duration:      0ms ‚úÖ
  Modified:      ‚úÖ NO ‚úÖ
```

### MARK Primitive
```
üéØ Drift Analysis Complete:
  Total Findings:     4 ‚úÖ
  Critical:           0 ‚úÖ
  High:               1 ‚úÖ
  Medium:             3 ‚úÖ
  Drift Detected:     ‚ö†Ô∏è  YES ‚úÖ

üìã Drift Findings:
  üü† [HIGH] mfaConfiguration ‚úÖ
     Expected: "ON" ‚úÖ
     Actual:   "OPTIONAL" ‚úÖ
     Description: mfaConfiguration drift detected: expected "ON", found "OPTIONAL" ‚úÖ
```

### RAID Primitive
```
‚öîÔ∏è  Raid Execution Complete:
  Raid ID:            RAID-9e266c06 ‚úÖ
  Target:             us-west-2_OPTIONAL001 ‚úÖ
  Attack Vector:      mfa-bypass ‚úÖ
  Outcome:            ‚ùå Failed ‚úÖ
  Controls Held:      ‚úÖ YES ‚úÖ
  Duration:           0ms ‚úÖ
  Findings:           2 ‚úÖ
  Lane Serialized:    ‚úÖ YES ‚úÖ
```

---

## Remaining Issues ‚ö†Ô∏è

### PLUNDER API Mismatch

**Implementation Signature:**
```typescript
async plunder(data: unknown, operation: OperationType): Promise<PlunderResult>

interface PlunderResult {
  path: string;
  recordsWritten: number;
}
```

**Demo Expectation:**
```typescript
const plunderResult = corsair.plunder(raidResult, evidencePath);

// Expects:
plunderResult.evidencePath
plunderResult.eventCount
plunderResult.chainVerified
plunderResult.immutable
plunderResult.auditReady
```

**Gap:** Complete API mismatch
- Implementation takes `(data, operation)` - generic evidence capture
- Demo expects `(raidResult, evidencePath)` - raid-specific with path
- Return type completely different

**To Fix:**
1. Either change implementation to match demo expectations
2. Or change demo to match implementation API
3. Or add overload: `plunder(raidResult, path)` for convenience

---

## Test Coverage Verification

### Before Changes:
- 50 tests passing
- Tests validated raw arrays

### After Changes:
- 50 tests passing ‚úÖ
- Tests validate wrapper objects with metadata
- 2 additional expect() calls (202 vs 200)

**No regression** - all tests adapted successfully.

---

## Lessons Learned

### 1. TDD Must Include Ergonomics

**What we did:**
‚úÖ Write tests
‚úÖ Make tests pass
‚ùå Validate ergonomic API

**What we should do:**
‚úÖ Write tests
‚úÖ Make tests pass
‚úÖ **Write integration/E2E demo**
‚úÖ **Validate demo uses API naturally**

### 2. Tests vs Reality Gap

**Tests tell you:** Does it work correctly?
**Demo tells you:** Is it pleasant to use?

Both are necessary. Green tests + failing demo = incomplete success.

### 3. Two Ways to Satisfy Test Contracts

**Option A: Return raw primitive**
```typescript
return findings;  // Tests pass ‚úÖ, API awkward ‚ùå
```

**Option B: Return wrapped object**
```typescript
return { findings, driftDetected, durationMs };  // Tests pass ‚úÖ, API ergonomic ‚úÖ
```

Both satisfy "tests pass" requirement. Only B satisfies "good API" requirement.

### 4. Demo Should Be Part of TDD Cycle

**Traditional TDD:**
Red ‚Üí Green ‚Üí Refactor

**Complete TDD for Libraries/APIs:**
Red ‚Üí Green ‚Üí **Demo** ‚Üí Refactor

If demo fails, you haven't completed "Green" yet.

---

## Summary

**Root Cause:** Tests validated functional correctness (does math work?) but not interface ergonomics (is API pleasant?). Implementation satisfied test contracts but not consumer expectations.

**Fix:** Added wrapper types (`MarkResult`), enhanced result objects (`ReconResult`), updated tests to access wrapper properties. 50/50 tests still pass.

**Result:**
- ‚úÖ RECON works in demo
- ‚úÖ MARK works in demo
- ‚úÖ RAID works in demo
- ‚ö†Ô∏è PLUNDER needs API redesign
- ‚ö†Ô∏è CHART not tested in demo yet
- ‚ö†Ô∏è ESCAPE not tested in demo yet

**Next Steps:**
1. Fix PLUNDER API to match demo expectations
2. Extend demo to show CHART and ESCAPE
3. Add integration test that runs full demo programmatically

---

**Fixed by:** Arudjreis
**Date:** 2026-01-31
**Test Evidence:** 50/50 pass (202 assertions)
**Demo Evidence:** 3/6 primitives working (RECON, MARK, RAID)
